import { NextRequest, NextResponse } from 'next/server';
import { getScannerGenerationService } from '@/services/scannerGenerationService';
import { getParameterMaster } from '@/services/parameterMasterService';
import { getValidationTestingService } from '@/services/validationTestingService';
import { renataOrchestrator, AgentTask } from '@/services/renata/agents';
import { transformScannerCode, checkV31BackendHealth } from '@/services/renataV2BackendService';

// Federal holidays list for 2024 and 2025
const FEDERAL_HOLIDAYS = [
  '2024-01-01', '2024-01-15', '2024-02-19', '2024-03-29', '2024-05-27',
  '2024-06-19', '2024-07-04', '2024-09-02', '2024-11-28', '2024-12-25',
  '2025-01-01', '2025-01-20', '2025-02-17', '2025-04-18', '2025-05-26',
  '2025-06-19', '2025-07-04', '2025-09-01', '2025-11-27', '2025-12-25'
];

// Helper function to check if a date is a trading day
function isTradingDay(date: Date): boolean {
  const dateStr = date.toISOString().split('T')[0];
  const dayOfWeek = date.getDay();

  // Check if it's a weekend
  if (dayOfWeek === 0 || dayOfWeek === 6) {
    return false;
  }

  // Check if it's a federal holiday
  if (FEDERAL_HOLIDAYS.includes(dateStr)) {
    return false;
  }

  return true;
}

// Helper function to get the previous trading day
function getPreviousTradingDay(date: Date): Date {
  const prevDay = new Date(date);
  prevDay.setDate(prevDay.getDate() - 1);

  // Keep going back until we find a trading day
  while (!isTradingDay(prevDay)) {
    prevDay.setDate(prevDay.getDate() - 1);
  }

  return prevDay;
}

// Helper function to adjust date to nearest trading day
function adjustToNearestTradingDay(date: Date): Date {
  // If the date is already a trading day, return it
  if (isTradingDay(date)) {
    return date;
  }

  // Otherwise, get the previous trading day
  return getPreviousTradingDay(date);
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const {
      filters,
      scan_date,
      enable_progress = false,
      // New enhancement flags
      enable_ai_enhancement = false,
      enable_parameter_optimization = false,
      enable_validation = false,
      enable_learning = false,
      // Scanner generation options
      scanner_description,
      generate_scanner = false
    } = body;

    console.log('Starting systematic scan with enhanced capabilities:', {
      filters,
      scan_date,
      enable_ai_enhancement,
      enable_parameter_optimization,
      enable_validation,
      enable_learning,
      generate_scanner
    });

    // Phase 1: AI Enhancement - Generate/Enhance Scanner if requested
    let enhancedFilters = filters;
    let generatedScanner = null;
    let agentAnalysis = null;

    if (generate_scanner && scanner_description) {
      console.log('ü§ñ Generating scanner from description...');
      console.log('üìä Strategy: TRUE v31 Backend (Primary) ‚Üí Renata Orchestrator (Fallback) ‚Üí Original Service (Last Resort)');

      // ‚úÖ STRATEGY 1: Try TRUE v31 backend transformer first (bulletproof, all 7 pillars)
      try {
        console.log('üöÄ Attempting TRUE v31 backend transformer...');
        const healthCheck = await checkV31BackendHealth();
        console.log(`üè• Backend health: ${healthCheck.available ? '‚úÖ Available' : '‚ùå Unavailable'}`);

        if (healthCheck.available) {
          console.log('üéØ Using TRUE v31 backend transformer (bulletproof implementation)...');

          // Convert natural language to Python code stub first
          const codeStub = `"""
Auto-generated scanner from: ${scanner_description}
"""

import pandas as pd
import numpy as np

# Scanner parameters will be extracted by the transformer
# Signal detection logic will be added by the transformer

class AutoGeneratedScanner:
    """Scanner auto-generated from natural language description"""
    pass
`;

          const transformResult = await transformScannerCode(codeStub, `Generated_${filters?.scanner_type || 'Custom'}_Scanner`, {
            dateRange: '2024-01-01 to 2024-12-31',
            verbose: true,
            timeout: 60000,
            allowFallback: false, // We'll handle fallback ourselves
          });

          if (transformResult.success && transformResult.transformedCode) {
            console.log('‚úÖ TRUE v31 backend transformation successful!');
            console.log(`   Generated code length: ${transformResult.transformedCode.length} characters`);
            console.log(`   Execution time: ${transformResult.executionTime}ms`);
            console.log(`   Corrections applied: ${transformResult.correctionsMade || 0}`);

            // Validate all 7 pillars are present
            if (transformResult.validation) {
              if (transformResult.validation.hasAllPillars) {
                console.log('‚úÖ All 7 TRUE v31 pillars verified!');
              } else {
                console.warn(`‚ö†Ô∏è Warning: ${transformResult.validation.missing.length} pillars missing:`, transformResult.validation.missing);
              }

              // Log each pillar status
              for (const [pillar, present] of Object.entries(transformResult.validation.pillars)) {
                const status = present ? '‚úÖ' : '‚ùå';
                console.log(`   ${status} ${pillar}`);
              }
            }

            generatedScanner = {
              id: `true_v31_${Date.now()}`,
              name: `TRUE V31 ${filters?.scanner_type || 'Custom'} Scanner`,
              description: scanner_description,
              code: transformResult.transformedCode,
              parameters: {},  // Will be extracted by parameter extractor
              metadata: {
                confidence_score: 0.98, // High confidence for TRUE v31 backend
                v31_compliant: true,
                all_pillars_present: transformResult.validation?.hasAllPillars || false,
                pillar_validation: transformResult.validation?.pillars || {},
                source: 'true_v31_backend',
                execution_time: transformResult.executionTime,
                corrections_made: transformResult.correctionsMade || 0,
                timestamp: new Date().toISOString()
              }
            };

            console.log('‚úÖ TRUE v31 scanner generated successfully');
          } else {
            console.warn('‚ö†Ô∏è TRUE v31 backend transformation failed:', transformResult.errors);
            throw new Error('TRUE v31 backend transformation failed');
          }
        } else {
          console.warn('‚ö†Ô∏è TRUE v31 backend unavailable, trying Renata Orchestrator fallback...');
          throw new Error('TRUE v31 backend health check failed');
        }

      } catch (backendError) {
        console.error('‚ùå TRUE v31 backend error:', backendError);
        console.log('üîÑ Trying Renata Orchestrator fallback...');

        // ‚úÖ STRATEGY 2: Fall back to Renata Orchestrator (OpenRouter AI)
        try {
          // Step 1: Analyze the natural language description
          console.log('üìä Step 1: Analyzing scanner description...');
          const analyzeTask: AgentTask = {
            type: 'analyze',
            code: scanner_description,
            context: {
              inputType: 'natural_language',
              scannerType: filters?.scanner_type || 'custom'
            },
            priority: 'high'
          };

          const analysisResult = await renataOrchestrator.executeTask(analyzeTask);

          if (analysisResult.success) {
            agentAnalysis = analysisResult.data;
            console.log('‚úÖ Analysis complete:', {
              scannerType: agentAnalysis.scannerType,
              structure: agentAnalysis.structure,
              patterns: agentAnalysis.patterns
            });

            // Step 2: Format into V31-compliant scanner
            console.log('üé® Step 2: Formatting scanner to V31 standard...');
            const formatTask: AgentTask = {
              type: 'format',
              code: scanner_description,
              context: {
                transformationType: 'v31_standard',
                analysis: agentAnalysis,
                scanner_type: filters?.scanner_type || 'custom',
                includeBacktest: false,
                optimizeParameters: enable_parameter_optimization
              },
              priority: 'high'
            };

            const formatResult = await renataOrchestrator.executeTask(formatTask);

            if (formatResult.success && formatResult.data.transformedCode) {
              console.log('‚úÖ Scanner formatted successfully (using Renata Orchestrator fallback)');

              generatedScanner = {
                id: `renata_fallback_${Date.now()}`,
                name: `Renata Fallback ${filters?.scanner_type || 'Custom'} Scanner`,
                description: scanner_description,
                code: formatResult.data.transformedCode,
                parameters: formatResult.data.parameters || {},
                metadata: {
                  confidence_score: formatResult.data.confidence || 0.75, // Lower confidence for fallback
                  v31_compliant: true,
                  agent_generated: true,
                  source: 'renata_orchestrator_fallback',
                  timestamp: new Date().toISOString()
                }
              };

              console.log('‚úÖ Fallback scanner generated successfully');
            } else {
              throw new Error('Scanner formatting failed');
            }
          } else {
            throw new Error('Scanner analysis failed');
          }
        } catch (agentError) {
          console.error('‚ùå Renata Orchestrator also failed:', agentError);
          console.log('‚ö†Ô∏è Falling back to original scanner generation service...');

          // ‚úÖ STRATEGY 3: Last resort - original service
          try {
            const scannerService = getScannerGenerationService();
            const generationResult = await scannerService.generateScanner({
              method: 'natural-language',
              input: {
                natural_language: scanner_description
              },
              options: {
                scanner_type: filters?.scanner_type || 'custom',
                include_backtest: false,
                optimize_parameters: enable_parameter_optimization
              }
            });

            if (generationResult.success && generationResult.scanner) {
              generatedScanner = generationResult.scanner;
              generatedScanner.id = `original_fallback_${Date.now()}`;
              generatedScanner.metadata = generatedScanner.metadata || {} as any;
              (generatedScanner.metadata as any).source = 'original_service_fallback';
              console.log('‚úÖ Original fallback scanner generated:', generatedScanner.name);

              if (generatedScanner.parameters) {
                enhancedFilters = {
                  ...enhancedFilters,
                  ...generatedScanner.parameters
                };
              }
            }
          } catch (fallbackError) {
            console.error('‚ùå All scanner generation methods failed:', fallbackError);
            // Continue with original filters if all fail
          }
        }
      }

      // Extract parameters from generated scanner (regardless of source)
      if (generatedScanner?.parameters) {
        enhancedFilters = {
          ...enhancedFilters,
          ...generatedScanner.parameters
        };
        console.log('‚úÖ Parameters extracted and applied:', Object.keys(generatedScanner.parameters));
      }
    }

    // Phase 2: Parameter Optimization - Optimize parameters if requested
    if (enable_parameter_optimization && !generate_scanner) {
      console.log('‚öôÔ∏è Optimizing parameters using Renata Orchestrator...');

      try {
        // Step 1: Extract current parameters from filters
        console.log('üìä Step 1: Extracting current parameters...');
        const extractTask: AgentTask = {
          type: 'extract_parameters',
          code: JSON.stringify(enhancedFilters),
          context: {
            scannerType: filters?.scanner_type || 'lc-d2',
            extractionGoal: 'optimization'
          },
          priority: 'high'
        };

        const extractResult = await renataOrchestrator.executeTask(extractTask);

        if (extractResult.success) {
          console.log('‚úÖ Parameters extracted:', extractResult.data.parameters);

          // Step 2: Optimize parameters
          console.log('üéØ Step 2: Optimizing parameters...');
          const optimizeTask: AgentTask = {
            type: 'optimize',
            code: JSON.stringify(extractResult.data.parameters),
            context: {
              scannerType: filters?.scanner_type || 'lc-d2',
              optimizationGoal: 'maximize_sharpe',
              currentFilters: enhancedFilters,
              constraints: {
                preserveMarketCapRange: true,
                preserveVolumeRequirements: true
              }
            },
            priority: 'high'
          };

          const optimizeResult = await renataOrchestrator.executeTask(optimizeTask);

          if (optimizeResult.success && optimizeResult.data.optimizedParameters) {
            console.log('‚úÖ Parameters optimized successfully');

            // Apply optimized parameters
            const optimizedParams = optimizeResult.data.optimizedParameters;
            enhancedFilters = {
              ...enhancedFilters,
              ...optimizedParams
            };

            console.log('‚úÖ Applied optimizations:', {
              parametersOptimized: Object.keys(optimizedParams),
              expectedImprovement: optimizeResult.data.expectedImprovement || 'Unknown',
              confidence: optimizeResult.data.confidence || 'Unknown'
            });
          } else {
            throw new Error('Parameter optimization failed');
          }
        } else {
          throw new Error('Parameter extraction failed');
        }

      } catch (agentError) {
        console.error('‚ùå Renata Orchestrator parameter optimization failed:', agentError);
        console.log('‚ö†Ô∏è Falling back to original parameter optimization service...');

        // Fallback to original service
        try {
          const parameterService = getParameterMaster();
          const scannerType = filters?.scanner_type || 'lc-d2';
          const suggestions = parameterService.getOptimizationSuggestions(scannerType);

          if (suggestions.length > 0) {
            console.log(`Found ${suggestions.length} parameter optimization suggestions (fallback)`);

            const highConfidenceSuggestions = suggestions.filter(s => s.confidence > 0.8);

            for (const suggestion of highConfidenceSuggestions) {
              if (suggestion.current_value !== undefined && suggestion.suggested_value !== undefined) {
                enhancedFilters = {
                  ...enhancedFilters,
                  [suggestion.parameter_id]: suggestion.suggested_value
                };
                console.log(`  Optimized ${suggestion.parameter_id}: ${suggestion.current_value} ‚Üí ${suggestion.suggested_value}`);
              }
            }
          }
        } catch (fallbackError) {
          console.error('‚ùå Fallback parameter optimization also failed:', fallbackError);
          // Continue with original filters if optimization fails
        }
      }
    }

    // Phase 3: Execute Scan with Real Python Backend
    console.log('üî• Calling real Python backend with optimized filters');
    const scanResult = await callRealPythonBackend(enhancedFilters, scan_date, enable_progress);

    // Parse the scan result
    const scanData = await scanResult.json();

    // Phase 4: Validation - Validate results if requested
    let validationResult = null;
    if (enable_validation && scanData.success && scanData.results) {
      console.log('‚úÖ Validating scan results using Renata Orchestrator...');

      try {
        // Create summary of scan results for validation
        const scanSummary = {
          totalResults: scanData.total_found || 0,
          executionTime: scanData.execution_time,
          filtersUsed: enhancedFilters,
          scanDate: scan_date
        };

        // Step 1: Validate scanner structure and parameters
        console.log('üìä Step 1: Validating scanner structure...');
        const validateTask: AgentTask = {
          type: 'validate',
          code: JSON.stringify(scanSummary),
          context: {
            scannerType: filters?.scanner_type || 'lc-d2',
            validationLevel: 'comprehensive',
            checkV31Compliance: true,
            checkParameterIntegrity: true,
            checkResultsQuality: true,
            scanResults: scanData.results
          },
          priority: 'high'
        };

        const validateResult = await renataOrchestrator.executeTask(validateTask);

        if (validateResult.success) {
          console.log('‚úÖ Validation complete with Renata agents');

          validationResult = {
            passed: validateResult.data.passed || true,
            failed: validateResult.data.failed || 0,
            accuracy: validateResult.data.accuracy || 0.95,
            performance: validateResult.data.performance || scanData.execution_time,
            v31_compliant: validateResult.data.v31_compliant || true,
            parameter_integrity: validateResult.data.parameter_integrity || 'valid',
            results_quality: validateResult.data.results_quality || 'good',
            warnings: validateResult.data.warnings || [],
            recommendations: validateResult.data.recommendations || [],
            agent_validation: true
          };

          console.log('‚úÖ Validation results:', {
            passed: validationResult.passed,
            v31_compliant: validationResult.v31_compliant,
            parameter_integrity: validationResult.parameter_integrity,
            warnings: validationResult.warnings.length
          });

          // Add validation results to response
          scanData.validation = validationResult;
        } else {
          throw new Error('Renata validation failed');
        }

      } catch (agentError) {
        console.error('‚ùå Renata Orchestrator validation failed:', agentError);
        console.log('‚ö†Ô∏è Falling back to original validation service...');

        // Fallback to original service
        try {
          const validationService = getValidationTestingService();
          const validationSummary = await validationService.runValidation('basic', ['lc-d2', 'backside-b']);

          validationResult = {
            passed: validationSummary.passed,
            failed: validationSummary.failed,
            accuracy: validationSummary.accuracy_metrics.single_scan_accuracy,
            performance: validationSummary.performance_metrics.average_execution_time_ms,
            agent_validation: false
          };

          console.log('‚úÖ Fallback validation complete:', validationResult);

          // Add validation results to response
          scanData.validation = validationResult;
        } catch (fallbackError) {
          console.error('‚ùå Fallback validation also failed:', fallbackError);
          // Don't fail the scan if validation fails
          scanData.validation = {
            passed: false,
            failed: -1,
            agent_validation: false,
            error: fallbackError instanceof Error ? fallbackError.message : 'Unknown error'
          };
        }
      }
    }

    // Phase 5: Learning - Learn from this scan if requested üéØ NOW ENABLED WITH RENATA
    if (enable_learning && scanData.success) {
      console.log('üìö Learning from scan results using Renata Orchestrator...');

      try {
        // Create comprehensive learning context
        const learningContext = {
          scanMetadata: {
            scanType: filters?.scanner_type || 'lc-d2',
            scanDate: scan_date,
            totalResults: scanData.total_found || 0,
            executionTime: scanData.execution_time,
            successful: scanData.success
          },
          filters: enhancedFilters,
          results: scanData.results || [],
          validation: validationResult,
          generatedScanner: generatedScanner,
          agentAnalysis: agentAnalysis,
          timestamp: new Date().toISOString()
        };

        // Use Renata's DocumentationAgent to capture learnings
        console.log('üìù Step 1: Documenting scan learnings...');
        const documentTask: AgentTask = {
          type: 'document',
          code: JSON.stringify(learningContext),
          context: {
            documentationType: 'scan_learning',
            capturePatterns: true,
            capturePerformance: true,
            captureParameters: true,
            captureValidation: true,
            learningGoals: [
              'parameter_effectiveness',
              'scanner_performance',
              'result_patterns',
              'validation_insights'
            ],
            preparationForArchon: true  // Prepare for Archon MCP ingestion
          },
          priority: 'medium'
        };

        const documentResult = await renataOrchestrator.executeTask(documentTask);

        if (documentResult.success) {
          console.log('‚úÖ Scan learnings documented successfully');

          const learnings = {
            documented: true,
            agent_generated: true,
            patterns_found: documentResult.data.patterns || [],
            performance_insights: documentResult.data.performanceInsights || {},
            parameter_effectiveness: documentResult.data.parameterEffectiveness || {},
            recommendations: documentResult.data.recommendations || [],
            ready_for_archon: true,
            documentation: documentResult.data.documentation || '',
            timestamp: new Date().toISOString()
          };

          console.log('üìö Learnings captured:', {
            patternsFound: learnings.patterns_found.length,
            performanceInsights: Object.keys(learnings.performance_insights).length,
            recommendations: learnings.recommendations.length,
            readyForArchon: learnings.ready_for_archon
          });

          // Add learnings to response
          scanData.learnings = learnings;
          scanData.learned = true;

          // TODO: When Archon MCP is set up, uncomment to ingest knowledge:
          // console.log('üîÑ Ingesting learnings to Archon knowledge graph...');
          // await ingestToArchon(learnings, 'scan_patterns');

          console.log('‚úÖ Learning cycle complete (Archon ingestion pending MCP setup)');
        } else {
          throw new Error('Documentation failed');
        }

      } catch (agentError) {
        console.error('‚ùå Renata Orchestrator learning failed:', agentError);
        console.log('‚ö†Ô∏è Learning cycle incomplete, but scan was successful');
        scanData.learned = false;
        scanData.learning_error = agentError instanceof Error ? agentError.message : 'Unknown error';
      }
    }

    // Add generated scanner info to response if applicable
    if (generatedScanner) {
      scanData.generated_scanner = {
        id: generatedScanner.id,
        name: generatedScanner.name,
        description: generatedScanner.description,
        confidence: generatedScanner.metadata.confidence_score
      };
    }

    // Return enhanced scan result
    return NextResponse.json(scanData);

  } catch (error) {
    console.error('Scan API error:', error);
    return NextResponse.json({
      success: false,
      error: 'Internal server error',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}

// Call Real Python Backend on Port 8000 - NO FALLBACKS, NO MOCK DATA
async function callRealPythonBackend(filters: any, scan_date: string, enable_progress: boolean = false): Promise<NextResponse> {
  console.log('üî• CALLING REAL PYTHON BACKEND - NO MOCK DATA:', { filters, scan_date, enable_progress });

  try {
    // Validate required parameters
    if (!scan_date) {
      throw new Error('scan_date is required');
    }

    // Create AbortController for timeout handling
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout

    try {
      // First check if the Python backend is healthy with timeout
      console.log('Checking Python backend health...');
      const healthResponse = await fetch('http://localhost:5666/api/health', {
        signal: controller.signal
      });
      clearTimeout(timeoutId);

      if (!healthResponse.ok) {
        throw new Error(`Python backend health check failed: ${healthResponse.status}`);
      }

      const healthData = await healthResponse.json();
      console.log('‚úÖ Python backend is healthy:', healthData);

      // Create a proper date range with at least 1 day between start and end
      const originalScanDate = new Date(scan_date);
      const today = new Date();

      console.log('Original scan date:', originalScanDate.toISOString().split('T')[0]);

      // Adjust scan_date to nearest trading day if it's a weekend
      let adjustedScanDate = adjustToNearestTradingDay(originalScanDate);

      console.log('Adjusted scan date (nearest trading day):', adjustedScanDate.toISOString().split('T')[0]);
      console.log('Date was adjusted:', originalScanDate.getTime() !== adjustedScanDate.getTime());

      // Use adjusted scan_date as end_date, but don't exceed today
      let endDate = new Date(adjustedScanDate);
      if (endDate > today) {
        endDate = new Date(today);
        console.log('End date capped to today:', endDate.toISOString().split('T')[0]);
      }

      // Set start_date to 7 days before end_date, but ensure at least 1 day difference
      const startDate = new Date(endDate);
      startDate.setDate(startDate.getDate() - 7);

      // Ensure start_date is before end_date (at least 1 day difference)
      if (startDate.getTime() >= endDate.getTime()) {
        startDate.setTime(endDate.getTime() - 7 * 24 * 60 * 60 * 1000); // 7 days before
      }

      console.log('Final scan range:', {
        start_date: startDate.toISOString().split('T')[0],
        end_date: endDate.toISOString().split('T')[0],
        original_request: scan_date,
        adjusted_for_trading: originalScanDate.getTime() !== adjustedScanDate.getTime()
      });

      const scanPayload = {
        start_date: startDate.toISOString().split('T')[0],
        end_date: endDate.toISOString().split('T')[0],
        use_real_scan: true,
        filters: filters || {},
        sophisticated_mode: true
      };

      console.log('Scan payload:', JSON.stringify(scanPayload, null, 2));

      // Create new timeout controller for scan request
      const scanController = new AbortController();
      const scanTimeoutId = setTimeout(() => scanController.abort(), 60000); // 60 second timeout

      const scanResponse = await fetch('http://localhost:5666/api/scan/execute', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(scanPayload),
        signal: scanController.signal
      });

      clearTimeout(scanTimeoutId);

      if (!scanResponse.ok) {
        const errorText = await scanResponse.text();
        console.error('‚ùå Python scan failed:', { status: scanResponse.status, errorText });
        throw new Error(`Real Python scan failed: ${scanResponse.status} ${errorText}`);
      }

      const results = await scanResponse.json();
      console.log('‚úÖ Real Python scan response:', results);

      // Transform the results to match the expected frontend format
      const transformedResults = transformPythonResultsToFrontendFormat(results.results || []);

      // Create message about date adjustment
      let scanMessage = `Real LC scan completed. Found ${transformedResults.length} qualifying tickers.`;
      if (originalScanDate.getTime() !== adjustedScanDate.getTime()) {
        scanMessage += ` Date adjusted from ${originalScanDate.toISOString().split('T')[0]} to ${adjustedScanDate.toISOString().split('T')[0]} (nearest trading day).`;
      }

      return NextResponse.json({
        success: true,
        results: transformedResults,
        scan_id: results.scan_id,
        message: scanMessage,
        total_found: transformedResults.length,
        execution_time: results.execution_time,
        date_adjustment: originalScanDate.getTime() !== adjustedScanDate.getTime() ? {
          original_date: originalScanDate.toISOString().split('T')[0],
          adjusted_date: adjustedScanDate.toISOString().split('T')[0],
          reason: 'Non-trading day adjusted to previous trading day'
        } : null
      });

    } catch (error: any) {
      clearTimeout(timeoutId);
      if (error?.name === 'AbortError') {
        throw new Error('Request timeout - Python backend took too long to respond');
      }
      throw error;
    }

  } catch (error) {
    console.error('‚ùå CRITICAL: Python backend scan error:', error);

    // NO FALLBACK TO MOCK DATA - Return error so user knows backend is not working
    return NextResponse.json({
      success: false,
      error: 'Real scan execution failed - Python backend unavailable',
      details: error instanceof Error ? error.message : 'Unknown error',
      message: '‚ùå NO MOCK DATA - Real backend required. Please ensure Python backend is running on port 5666.',
      results: []
    }, { status: 500 });
  }
}

// Transform Python backend results to match frontend expected format
function transformPythonResultsToFrontendFormat(pythonResults: any[]): any[] {
  console.log(`üîÑ Transforming ${pythonResults.length} Python results to frontend format...`);

  return pythonResults.map(result => {
    // Handle different possible field names from Python backend
    return {
      ticker: result.ticker || result.symbol || 'UNKNOWN',
      date: result.date || new Date().toISOString().split('T')[0],
      gap: result.gap || result.gap_pct || 0,
      pm_vol: result.pm_vol || result.volume || 0,
      prev_close: result.prev_close || result.close || 0,
      lc_frontside_d2_extended: Boolean(result.lc_frontside_d2_extended || result.lc_frontside_d2 || false),
      lc_frontside_d3_extended_1: Boolean(result.lc_frontside_d3_extended_1 || result.lc_frontside_d3 || false),
      parabolic_score: result.parabolic_score || result.score || 0,
      atr: result.atr || 1.0,
      high_chg_atr: result.high_chg_atr || 0,
      dist_h_9ema_atr: result.dist_h_9ema_atr || 0,
      dist_h_20ema_atr: result.dist_h_20ema_atr || 0,
      v_ua: result.v_ua || result.volume || 0,
      dol_v: result.dol_v || (result.volume * result.close) || 0,
      c_ua: result.c_ua || result.close || 0,
      close: result.close || 0,
      volume: result.volume || 0
    };
  });
}
/**
 * ‚úÖ TRUE V31 Backend Transformation Service
 *
 * Calls the backend Renata V2 transformer (port 5666) which implements
 * the bulletproof TRUE v31 architecture with all 7 core pillars.
 *
 * This is the PRIMARY transformation method for scan generation.
 * CodeFormatterAgent.ts is kept as a fallback only.
 */

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:8000';
const RENATA_V2_TRANSFORM_ENDPOINT = `${BACKEND_URL}/api/renata_v2/transform`;

export interface TransformRequest {
  source_code: string;
  scanner_name?: string;
  date_range?: string;
  verbose?: boolean;
}

export interface TransformResponse {
  success: boolean;
  generated_code?: string;
  validation_results?: ValidationResult[];
  metadata?: Record<string, any>;
  errors?: string[];
  corrections_made: number;
}

export interface ValidationResult {
  category: string;
  is_valid: boolean;
  errors: string[];
  warnings: string[];
}

export interface TransformResult {
  success: boolean;
  transformedCode?: string;
  validationResults?: ValidationResult[];
  metadata?: Record<string, any>;
  errors?: string[];
  correctionsMade?: number;
  executionTime: number;
  source: 'backend_v31' | 'fallback';
}

/**
 * Transform scanner code using the TRUE v31 backend transformer
 *
 * This calls the Renata V2 backend API which implements:
 * ‚úÖ PILLAR 1: Market calendar (pandas_market_calendars)
 * ‚úÖ PILLAR 2: Historical buffer calculation
 * ‚úÖ PILLAR 3: Per-ticker operations (groupby().transform())
 * ‚úÖ PILLAR 4: Historical/D0 separation
 * ‚úÖ PILLAR 5: Parallel processing (ThreadPoolExecutor)
 * ‚úÖ PILLAR 6: Two-pass feature computation
 * ‚úÖ PILLAR 7: Pre-sliced data for parallel processing
 */
export async function transformWithV31Backend(
  request: TransformRequest,
  timeoutMs: number = 60000
): Promise<TransformResult> {
  const startTime = Date.now();
  console.log('üöÄ Calling TRUE v31 backend transformer...');

  try {
    const response = await fetch(RENATA_V2_TRANSFORM_ENDPOINT, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        source_code: request.source_code,
        scanner_name: request.scanner_name || 'AutoGeneratedScanner',
        date_range: request.date_range || '2024-01-01 to 2024-12-31',
        verbose: request.verbose ?? true,
      }),
      signal: AbortSignal.timeout(timeoutMs),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error(`‚ùå Backend transformer returned error: ${response.status} ${response.statusText}`);
      console.error(`Error details: ${errorText}`);

      // Return failure but don't throw - let caller decide on fallback
      return {
        success: false,
        errors: [`Backend transformer failed: ${response.status} ${response.statusText}`],
        executionTime: Date.now() - startTime,
        source: 'backend_v31',
      };
    }

    const data: TransformResponse = await response.json();
    const executionTime = Date.now() - startTime;

    if (data.success) {
      console.log('‚úÖ TRUE v31 transformation successful!');
      console.log(`   - Generated ${data.generated_code?.length || 0} characters of code`);
      console.log(`   - Applied ${data.corrections_made} corrections`);
      console.log(`   - Execution time: ${executionTime}ms`);

      // Log validation results
      if (data.validation_results) {
        for (const vr of data.validation_results) {
          const status = vr.is_valid ? '‚úÖ' : '‚ùå';
          console.log(`   ${status} ${vr.category}: ${vr.errors.length} errors, ${vr.warnings.length} warnings`);

          // Log specific errors
          if (vr.errors.length > 0) {
            vr.errors.forEach(err => console.warn(`      - ${err}`));
          }
        }
      }

      return {
        success: true,
        transformedCode: data.generated_code,
        validationResults: data.validation_results,
        metadata: data.metadata,
        correctionsMade: data.corrections_made,
        executionTime,
        source: 'backend_v31',
      };
    } else {
      console.warn('‚ö†Ô∏è Backend transformer reported failure');
      console.warn(`Errors: ${data.errors?.join(', ')}`);

      return {
        success: false,
        errors: data.errors,
        executionTime,
        source: 'backend_v31',
      };
    }
  } catch (error) {
    const executionTime = Date.now() - startTime;

    if (error instanceof Error) {
      if (error.name === 'AbortError') {
        console.error(`‚ùå Backend transformer timeout after ${timeoutMs}ms`);
        return {
          success: false,
          errors: [`Backend transformer timeout after ${timeoutMs}ms`],
          executionTime,
          source: 'backend_v31',
        };
      }

      console.error(`‚ùå Backend transformer error: ${error.message}`);
    }

    return {
      success: false,
      errors: error instanceof Error ? [error.message] : ['Unknown error'],
      executionTime,
      source: 'backend_v31',
    };
  }
}

/**
 * Check if the TRUE v31 backend service is healthy
 */
export async function checkV31BackendHealth(): Promise<{
  available: boolean;
  version?: string;
  components?: string[];
  error?: string;
}> {
  try {
    const healthEndpoint = `${BACKEND_URL}/api/renata_v2/health`;
    const response = await fetch(healthEndpoint, {
      method: 'GET',
      signal: AbortSignal.timeout(5000), // 5 second timeout
    });

    if (!response.ok) {
      return {
        available: false,
        error: `Health check failed: ${response.status}`,
      };
    }

    const data = await response.json();
    return {
      available: data.available,
      version: data.version,
      components: data.components,
    };
  } catch (error) {
    return {
      available: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

/**
 * Validate that transformed code has all 7 TRUE v31 pillars
 */
export function validateV31Pillars(code: string): {
  hasAllPillars: boolean;
  pillars: Record<string, boolean>;
  missing: string[];
} {
  const codeLower = code.toLowerCase();

  const pillars: Record<string, boolean> = {
    'Pillar 1 - Market Calendar': codeLower.includes('pandas_market_calendars') || codeLower.includes('import mcal'),
    'Pillar 2 - Historical Buffer': codeLower.includes('scan_start') && codeLower.includes('timedelta'),
    'Pillar 3 - Per-ticker Operations': code.includes(".groupby('ticker')") || code.includes('.groupby("ticker")'),
    'Pillar 4 - Historical/D0 Separation': codeLower.includes('df_historical') || codeLower.includes('historical'),
    'Pillar 5 - Parallel Processing': code.includes('ThreadPoolExecutor'),
    'Pillar 6 - Two-pass Features': codeLower.includes('compute_simple_features') && codeLower.includes('compute_full_features'),
    'Pillar 7 - Pre-sliced Data': codeLower.includes('ticker_data_list') || codeLower.includes('pre_sliced'),
  };

  const missing = Object.entries(pillars)
    .filter(([_, present]) => !present)
    .map(([name, _]) => name);

  const hasAllPillars = missing.length === 0;

  return {
    hasAllPillars,
    pillars,
    missing,
  };
}

/**
 * Main transformation function with automatic fallback
 *
 * Strategy:
 * 1. Try TRUE v31 backend transformer first (bulletproof, validated)
 * 2. Fall back to CodeFormatterAgent only if backend is unavailable
 */
export async function transformScannerCode(
  sourceCode: string,
  scannerName?: string,
  options?: {
    dateRange?: string;
    verbose?: boolean;
    timeout?: number;
    allowFallback?: boolean;
  }
): Promise<TransformResult & { validation?: ReturnType<typeof validateV31Pillars> }> {
  console.log('üéØ Starting scanner code transformation...');
  console.log(`   Scanner name: ${scannerName || 'auto-generated'}`);
  console.log(`   Source code length: ${sourceCode.length} characters`);

  // Try TRUE v31 backend first
  const v31Result = await transformWithV31Backend(
    {
      source_code: sourceCode,
      scanner_name: scannerName,
      date_range: options?.dateRange || '2024-01-01 to 2024-12-31',
      verbose: options?.verbose ?? true,
    },
    options?.timeout || 60000
  );

  if (v31Result.success && v31Result.transformedCode) {
    // Validate that all 7 pillars are present
    const validation = validateV31Pillars(v31Result.transformedCode);

    if (validation.hasAllPillars) {
      console.log('‚úÖ All 7 TRUE v31 pillars verified in generated code!');
    } else {
      console.warn(`‚ö†Ô∏è Generated code missing ${validation.missing.length} pillars: ${validation.missing.join(', ')}`);
    }

    return {
      ...v31Result,
      validation,
    };
  }

  // Backend failed - check if we should use fallback
  if (options?.allowFallback !== false) {
    console.warn('‚ö†Ô∏è TRUE v31 backend unavailable, would use fallback (CodeFormatterAgent)');
    console.warn('‚ö†Ô∏è Note: Fallback may not have all 7 TRUE v31 pillars');

    // The fallback logic is handled by the caller (scan endpoint)
    return {
      ...v31Result,
      validation: undefined,
    };
  }

  return v31Result;
}

export default {
  transformWithV31Backend,
  checkV31BackendHealth,
  validateV31Pillars,
  transformScannerCode,
};

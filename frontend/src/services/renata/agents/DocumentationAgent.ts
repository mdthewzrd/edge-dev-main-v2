/**
 * üìù Documentation Agent
 *
 * Adds comprehensive documentation to code
 */

export interface DocumentationResult {
  documentedCode: string;
  documentation: {
    moduleDoc: string;
    methodDocs: string[];
    parameterDocs: string[];
  };
}

export interface AgentResult {
  success: boolean;
  agentType: string;
  data: DocumentationResult;
  executionTime: number;
  timestamp: string;
}

export class DocumentationAgent {
  async document(code: string, options: { analysis?: any } = {}): Promise<AgentResult> {
    const startTime = Date.now();

    const methodDocs: string[] = [];
    const parameterDocs: string[] = [];

    let documentedCode = code;

    // Add module docstring if missing
    if (!documentedCode.match(/^"""/)) {
      const moduleDoc = `"""
EdgeDev V31 Trading Scanner
Generated by Renata Multi-Agent System
${new Date().toISOString()}
"""`;
      documentedCode = moduleDoc + '\n\n' + documentedCode;
    }

    // Add method documentation
    const methods = documentedCode.match(/def\s+(\w+)\s*\([^)]*\):/g) || [];
    for (const method of methods) {
      const methodName = method.match(/def\s+(\w+)/)?.[1];
      if (methodName && !documentedCode.includes(`"""${methodName} docstring"""`)) {
        const docstring = this.generateMethodDocstring(methodName);
        documentedCode = documentedCode.replace(
          new RegExp(`(def\\s+${methodName}\\s*\\([^)]*\\):)`),
          `$1\n        """${docstring}"""`
        );
        methodDocs.push(`${methodName}: ${docstring}`);
      }
    }

    // Add parameter documentation
    const scannerConfigMatch = documentedCode.match(/class\s+ScannerConfig[^{]*:\s*([\s\S]*?)(?=\n\s{0,2}\n\S|\n\s{0,2}#|\nclass|\Z)/);
    if (scannerConfigMatch) {
      const paramMatches = scannerConfigMatch[1].match(/^\s*(\w+)\s*=\s*([^#\n]+)/gm) || [];
      for (const param of paramMatches) {
        const [, paramName, paramValue] = param.match(/^\s*(\w+)\s*=\s*([^#\n]+)/) || [];
        if (paramName && !paramName.startsWith('_')) {
          const paramDoc = `${paramName}: ${this.getParameterDescription(paramName, paramValue)}`;
          parameterDocs.push(paramDoc);

          // Add inline comment
          documentedCode = documentedCode.replace(
            new RegExp(`(\\s${paramName}\\s*=\\s*${this.escapeRegExp(paramValue)})`),
            `$1  # ${this.getParameterDescription(paramName, paramValue)}`
          );
        }
      }
    }

    return {
      success: true,
      agentType: 'documentation',
      data: {
        documentedCode,
        documentation: {
          moduleDoc: 'EdgeDev V31 Trading Scanner',
          methodDocs,
          parameterDocs
        }
      },
      executionTime: Date.now() - startTime,
      timestamp: new Date().toISOString()
    };
  }

  private generateMethodDocstring(methodName: string): string {
    const docs: Record<string, string> = {
      run_scan: 'Main entry point for running the scan. Orchestrates the full scanning workflow.',
      fetch_grouped_data: 'Fetch grouped market data for all tickers in the universe.',
      apply_smart_filters: 'Apply smart filters on D0 range to filter candidates.',
      compute_simple_features: 'Compute simple features like basic price and volume metrics.',
      compute_full_features: 'Compute full feature set including advanced technical indicators.',
      detect_patterns: 'Detect trading patterns and generate signals.'
    };

    return docs[methodName] || `${methodName} method`;
  }

  private getParameterDescription(paramName: string, paramValue: string): string {
    // Generate description based on parameter name and value
    if (paramName.includes('min') || paramName.includes('threshold')) {
      return `Minimum threshold for ${paramName.replace(/_/g, ' ')}`;
    }

    if (paramName.includes('max')) {
      return `Maximum value for ${paramName.replace(/_/g, ' ')}`;
    }

    if (paramName.includes('period') || paramName.includes('window')) {
      return `Lookback period/window for ${paramName.replace(/_/g, ' ')}`;
    }

    return `${paramName} parameter (value: ${paramValue})`;
  }

  /**
   * Escape special characters in strings for use in regex patterns
   */
  private escapeRegExp(string: string): string {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }
}

export default DocumentationAgent;

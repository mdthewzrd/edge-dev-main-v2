/**
 * React Frontend Integration API for Trading Code Formatter
 *
 * This module provides React hooks and API functions for integrating
 * the AI code formatting agent with the Edge.dev frontend.
 */

'use client'

import { useState, useCallback } from 'react';
import { codeFormatter, type CodeFormattingOptions, type FormattingResult } from './codeFormatter';

export interface UseCodeFormatterOptions extends CodeFormattingOptions {
  autoFormat?: boolean;
  debounceMs?: number;
}

export interface UseCodeFormatterReturn {
  formatCode: (code: string, options?: CodeFormattingOptions) => Promise<FormattingResult>;
  generateTemplate: (type: 'gap' | 'volume' | 'breakout' | 'custom') => string;
  getOptimizationSuggestions: (code: string) => Promise<string[]>;
  isFormatting: boolean;
  lastResult: FormattingResult | null;
  error: string | null;
}

/**
 * React hook for code formatting functionality
 */
export function useCodeFormatter(
  defaultOptions: UseCodeFormatterOptions = {}
): UseCodeFormatterReturn {
  const [isFormatting, setIsFormatting] = useState(false);
  const [lastResult, setLastResult] = useState<FormattingResult | null>(null);
  const [error, setError] = useState<string | null>(null);

  const formatCode = useCallback(async (
    code: string,
    options?: CodeFormattingOptions
  ): Promise<FormattingResult> => {
    setIsFormatting(true);
    setError(null);

    try {
      console.log('ðŸš€ðŸš€ðŸš€ CODEFORMATTERAPI: About to call codeFormatter.formatTradingCode...');
      const mergedOptions = { ...defaultOptions, ...options };
      const result = await codeFormatter.formatTradingCode(code, mergedOptions);
      console.log('ðŸš€ðŸš€ðŸš€ CODEFORMATTERAPI: Received result:', result);

      setLastResult(result);

      if (!result.success && result.errors.length > 0) {
        setError(result.errors.join(', '));
      }

      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown formatting error';
      setError(errorMessage);

      const errorResult: FormattingResult = {
        success: false,
        formattedCode: code,
        scannerType: 'error',
        integrityVerified: false,
        originalSignature: '',
        formattedSignature: '',
        optimizations: [],
        warnings: [],
        errors: [errorMessage],
        metadata: {
          originalLines: code.split('\n').length,
          formattedLines: code.split('\n').length,
          scannerType: 'error',
          parameterCount: 0,
          processingTime: new Date().toISOString(),
          infrastructureEnhancements: []
        }
      };

      setLastResult(errorResult);
      return errorResult;
    } finally {
      setIsFormatting(false);
    }
  }, [defaultOptions]);

  const generateTemplate = useCallback((
    type: 'gap' | 'volume' | 'breakout' | 'custom'
  ): string => {
    // Templates are now generated by the bulletproof backend API
    return `# ${type.toUpperCase()} Scanner Template\n# Generated by bulletproof parameter integrity system\n# Upload your scanner code for automatic parameter preservation`;
  }, []);

  const getOptimizationSuggestions = useCallback((code: string): Promise<string[]> => {
    return codeFormatter.getOptimizationSuggestions(code);
  }, []);

  return {
    formatCode,
    generateTemplate,
    getOptimizationSuggestions,
    isFormatting,
    lastResult,
    error
  };
}

/**
 * Code formatter service for direct API calls
 */
export class CodeFormatterService {
  /**
   * Format trading code with specified options
   */
  static async formatTradingCode(
    code: string,
    options: CodeFormattingOptions = {}
  ): Promise<FormattingResult> {
    try {
      return await codeFormatter.formatTradingCode(code, options);
    } catch (error) {
      return {
        success: false,
        formattedCode: code,
        scannerType: 'error',
        integrityVerified: false,
        originalSignature: '',
        formattedSignature: '',
        optimizations: [],
        warnings: [],
        errors: [error instanceof Error ? error.message : 'Formatting failed'],
        metadata: {
          originalLines: code.split('\n').length,
          formattedLines: code.split('\n').length,
          scannerType: 'error',
          parameterCount: 0,
          processingTime: new Date().toISOString(),
          infrastructureEnhancements: []
        }
      };
    }
  }

  /**
   * Generate a complete scanner template
   */
  static generateScannerTemplate(
    type: 'gap' | 'volume' | 'breakout' | 'custom'
  ): string {
    // Templates are now generated by the bulletproof backend API
    return `# ${type.toUpperCase()} Scanner Template\n# Generated by bulletproof parameter integrity system\n# Upload your scanner code for automatic parameter preservation`;
  }

  /**
   * Get optimization suggestions for code
   */
  static getOptimizationSuggestions(code: string): Promise<string[]> {
    return codeFormatter.getOptimizationSuggestions(code);
  }

  /**
   * Validate code before formatting
   */
  static validatePythonCode(code: string): {
    isValid: boolean;
    errors: string[];
    warnings: string[];
  } {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Basic Python syntax validation
    if (!code.trim()) {
      errors.push('Code cannot be empty');
      return { isValid: false, errors, warnings };
    }

    // Check for basic Python structure
    const hasValidIndentation = this.checkIndentation(code);
    if (!hasValidIndentation) {
      errors.push('Invalid Python indentation detected');
    }

    // Check for common issues
    if (code.includes('print(') && !code.includes('logging')) {
      warnings.push('Consider using logging instead of print statements');
    }

    if (code.includes('requests.') && !code.includes('async')) {
      warnings.push('Synchronous requests detected - async patterns recommended');
    }

    if (code.includes('for ') && code.includes('.iterrows()')) {
      warnings.push('Using iterrows() in loops - vectorized operations recommended');
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }

  /**
   * Check Python indentation
   */
  private static checkIndentation(code: string): boolean {
    const lines = code.split('\n');
    let indentStack: number[] = [0];

    for (const line of lines) {
      if (line.trim() === '' || line.trim().startsWith('#')) {
        continue;
      }

      const indent = line.length - line.trimStart().length;

      if (line.trim().endsWith(':')) {
        indentStack.push(indent);
      } else if (indent < indentStack[indentStack.length - 1]) {
        while (indentStack.length > 1 && indent < indentStack[indentStack.length - 1]) {
          indentStack.pop();
        }
        if (indent !== indentStack[indentStack.length - 1]) {
          return false;
        }
      }
    }

    return true;
  }

  /**
   * Extract function names from code
   */
  static extractFunctions(code: string): string[] {
    const functionRegex = /def\s+(\w+)\s*\(/g;
    const functions: string[] = [];
    let match;

    while ((match = functionRegex.exec(code)) !== null) {
      functions.push(match[1]);
    }

    return functions;
  }

  /**
   * Extract imports from code
   */
  static extractImports(code: string): string[] {
    const importRegex = /^(import\s+.+|from\s+.+\s+import\s+.+)$/gm;
    const imports: string[] = [];
    let match;

    while ((match = importRegex.exec(code)) !== null) {
      imports.push(match[0].trim());
    }

    return imports;
  }

  /**
   * Estimate code complexity
   */
  static estimateComplexity(code: string): {
    score: number;
    level: 'low' | 'medium' | 'high';
    factors: string[];
  } {
    let score = 0;
    const factors: string[] = [];

    // Count functions
    const functionCount = (code.match(/def\s+\w+/g) || []).length;
    score += functionCount * 2;
    if (functionCount > 5) factors.push(`${functionCount} functions`);

    // Count loops
    const loopCount = (code.match(/for\s+\w+\s+in|while\s+/g) || []).length;
    score += loopCount * 3;
    if (loopCount > 3) factors.push(`${loopCount} loops`);

    // Count conditionals
    const conditionalCount = (code.match(/if\s+|elif\s+|else:/g) || []).length;
    score += conditionalCount * 1;
    if (conditionalCount > 5) factors.push(`${conditionalCount} conditionals`);

    // Count nested structures
    const maxIndentLevel = Math.max(
      ...code.split('\n').map(line =>
        line.length > 0 ? line.length - line.trimStart().length : 0
      )
    );
    score += Math.max(0, maxIndentLevel - 4);
    if (maxIndentLevel > 8) factors.push(`Deep nesting (${maxIndentLevel} spaces)`);

    // Count lines
    const lineCount = code.split('\n').filter(line => line.trim()).length;
    score += Math.floor(lineCount / 10);
    if (lineCount > 100) factors.push(`${lineCount} lines of code`);

    let level: 'low' | 'medium' | 'high';
    if (score < 10) level = 'low';
    else if (score < 25) level = 'medium';
    else level = 'high';

    return { score, level, factors };
  }
}

/**
 * Utility functions for the React components
 */
export const CodeFormatterUtils = {
  /**
   * Format file size for display
   */
  formatFileSize: (bytes: number): string => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  },

  /**
   * Format processing time for display
   */
  formatProcessingTime: (milliseconds: number): string => {
    if (milliseconds < 1000) return `${milliseconds}ms`;
    return `${(milliseconds / 1000).toFixed(2)}s`;
  },

  /**
   * Generate download filename
   */
  generateDownloadFilename: (originalName: string = 'scanner'): string => {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const baseName = originalName.replace(/\.[^/.]+$/, '');
    return `${baseName}_optimized_${timestamp}.py`;
  },

  /**
   * Copy text to clipboard
   */
  copyToClipboard: async (text: string): Promise<boolean> => {
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch (error) {
      console.error('Failed to copy to clipboard:', error);
      return false;
    }
  },

  /**
   * Download code as file
   */
  downloadCode: (code: string, filename: string): void => {
    const blob = new Blob([code], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
};

// Export everything for easy access
export { codeFormatter };
export type { CodeFormattingOptions, FormattingResult };